<script>
// Track data
const tracks = {{{json tracks}}};

// Music Player Logic
(function() {
    let currentTrackIndex = -1;
    let isPlaying = false;
    const audioElement = document.getElementById('bottom-audio-element');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const trackTitle = document.getElementById('track-title');
    const trackSubtitle = document.getElementById('track-subtitle');
    const currentTimeEl = document.getElementById('current-time');
    const durationEl = document.getElementById('duration');
    const progressBar = document.getElementById('progress-bar');
    const progressContainer = document.getElementById('progress-container');
    
    // Format time
    function formatTime(seconds) {
        if (isNaN(seconds)) return '0:00';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    // Load track
    function loadTrack(index) {
        if (index < 0 || index >= tracks.length) return;
        
        currentTrackIndex = index;
        const track = tracks[index];
        
        audioElement.src = track.src;
        trackTitle.textContent = track.title;
        trackSubtitle.textContent = track.artist;
        
        // Update active state in track list
        document.querySelectorAll('.track-item').forEach((item, i) => {
            if (i === index) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        });
        
        // Update MediaSession API
        if ('mediaSession' in navigator) {
            navigator.mediaSession.metadata = new MediaMetadata({
                title: track.title,
                artist: track.artist,
                album: 'Sinister Dexter'
            });
        }
    }
    
    // Play/Pause
    function togglePlayPause() {
        if (currentTrackIndex === -1) {
            loadTrack(0);
        }
        
        if (isPlaying) {
            audioElement.pause();
            isPlaying = false;
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
        } else {
            audioElement.play();
            isPlaying = true;
            playIcon.classList.add('hidden');
            pauseIcon.classList.remove('hidden');
        }
    }
    
    // Previous track
    function prevTrack() {
        if (currentTrackIndex > 0) {
            loadTrack(currentTrackIndex - 1);
            if (isPlaying) audioElement.play();
        }
    }
    
    // Next track
    function nextTrack() {
        if (currentTrackIndex < tracks.length - 1) {
            loadTrack(currentTrackIndex + 1);
            if (isPlaying) audioElement.play();
        }
    }
    
    // Event listeners
    playPauseBtn?.addEventListener('click', togglePlayPause);
    prevBtn?.addEventListener('click', prevTrack);
    nextBtn?.addEventListener('click', nextTrack);
    
    // Track list click handlers
    document.querySelectorAll('.track-item').forEach((item, index) => {
        item.addEventListener('click', function() {
            loadTrack(index);
            audioElement.play();
            isPlaying = true;
            playIcon.classList.add('hidden');
            pauseIcon.classList.remove('hidden');
        });
    });
    
    // Audio element events
    audioElement?.addEventListener('timeupdate', () => {
        const progress = (audioElement.currentTime / audioElement.duration) * 100;
        progressBar.style.width = `${progress}%`;
        currentTimeEl.textContent = formatTime(audioElement.currentTime);
    });
    
    audioElement?.addEventListener('loadedmetadata', () => {
        durationEl.textContent = formatTime(audioElement.duration);
    });
    
    audioElement?.addEventListener('ended', () => {
        nextTrack();
    });
    
    // Progress bar click
    progressContainer?.addEventListener('click', (e) => {
        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        audioElement.currentTime = percent * audioElement.duration;
    });
    
    // MediaSession API handlers
    if ('mediaSession' in navigator) {
        navigator.mediaSession.setActionHandler('play', togglePlayPause);
        navigator.mediaSession.setActionHandler('pause', togglePlayPause);
        navigator.mediaSession.setActionHandler('previoustrack', prevTrack);
        navigator.mediaSession.setActionHandler('nexttrack', nextTrack);
    }
    
    // Auto-load first track (Broadband Connection)
    if (tracks.length > 0) {
        loadTrack(0);
    }
})();
</script>

<!-- TikTok Embed Script -->
<script async src="https://www.tiktok.com/embed.js"></script>

<!-- Hero Video Background Handler -->
<script>
(function() {
    const heroVideo = document.querySelector('#hero video');
    if (!heroVideo) return;

    // Handle responsive video source switching
    function updateVideoSource() {
        const isMobile = window.innerWidth <= 768;
        const currentSrc = heroVideo.querySelector('source[src*="hero-mobile.mp4"]');
        const desktopSrc = heroVideo.querySelector('source[src*="hero-desktop.mp4"]');

        // Browsers will automatically select the appropriate source based on media queries
        // But we can force reload if needed on resize
        heroVideo.load();
    }

    // Ensure video plays (some browsers block autoplay)
    heroVideo.play().catch(function(error) {
        console.log('Video autoplay prevented:', error);
    });

    // Pause video when tab is not visible (save bandwidth/battery)
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            heroVideo.pause();
        } else {
            heroVideo.play().catch(function() {});
        }
    });

    // Reduce motion for users who prefer it
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        heroVideo.pause();
        heroVideo.style.display = 'none';
    }
})();
</script>